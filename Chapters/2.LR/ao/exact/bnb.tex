\subsubsection{Branch and Bound}
\label{sec:bnb}

Branch and Bound ($B\&B$) is one of the most used tools to solve large NP-hard combinatorial optimization problems. The software \textit{Concorde}, uses a Branch and Bound algorithm, and was used to solve all 110 instances of the \textit{TSPLib}, reporting exact solutions in every problem, including a instance with 89.900 nodes, although it required more than 110 CPU years. To be precise, $B\&B$ should be classified as an algorithm paradigm, constituted by 3 main parts, which have to be chosen according to the problem under consideration, and for which many options may exist \cite{bnb_review}.

The force of the $B\&B$ comes from it being a search algorithm which (indirectly) searches the complete search space of the problem. Since this is not directly feasible, due to the common exponential growth of the solution space, $B\&B$ takes advantage of \textit{bounds}, combined with information regarding the current best solution,to safely discard certain solutions among the search space.

At any point of the algorithm, there is a \textit{current solution}, and a \textit{pool} of unexplored subsets of the solution space. At the beginning of the algorithm, this pool consists of (only) the root node, and at the end of the algorithm, it will consists of an empty set, meaning that the entire search space was successfully explored. The initialization of the $B\&B$ requires the \textit{incumbent}, which denotes the objective function value of the current solution, to be initialized as $\infty$. If it is possible to generate an initial feasible solution using some heuristic method, this solution is recorded and its objective value is set as incumbent. The process of generating an initial solution has usually a positive impact on the $B\&B$ algorithm. After the initialization, this algorithm enters an iterative process, until the pool of unexplored subsets is empty. This processes consists of three main steps: $i$) selection of a node to process; $ii$) the bound calculation; and $iii$) branching.

Branch and Bound algorithms vary according to the strategies established for each of the three main steps of the iterative process, as well as the initial heuristic. In any case, the bounding function selected is the key for any good branch and bounding algorithm, because the selection of a bad function can not be compensated with good choices on the branching and bounding strategies. For example, consider the trivial case where the bounding function is the constant value of 0. It is obvious that this will always be a lower bound to the problem, but it does not produce any quality information of which solutions to discard. Ideally, the value of the bounding function for a given subproblem should be equal to the value of the beast feasible solution  to that problem. This is usually not possible, since subproblems may also be NP-hard. Thus, bounding functions are chosen according to the proximity to the best possible value, and to its time complexity - usually restricted to polynomial time.

To complete this overview, selection strategies for the TSP usually revolve around Best First, Depth First and Breadth First Search. There are several works which discuss the main differences of each selection strategy and report on which strategy might be more adequate according to the problem characteristics. Finally, the branching strategy in the TSP usually consists of selecting any node with a degree 3 or higher in the search tree. There are several comments around this strategy, some authors opting for the selection of a node with a low bound, as this will, theoretically, reduce the number of searches when processing the node with higher bounds.




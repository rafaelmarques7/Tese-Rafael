\subsubsection{Branch and Bound}
\label{sec:bnb}

\ac{BB} is one of the most used tools to solve large NP-hard combinatorial optimization problems. As an example, the software tool \textit{Concorde} uses a Branch and Bound algorithm, and it was used to solve all 110 instances of the \textit{TSPLib}, reporting exact solutions in every problem, including a instance with 89.900 nodes, although it required more than 110 CPU years. To be precise, $B\&B$ should be classified as an algorithm paradigm, constituted by 3 main parts, which have to be chosen according to the problem under consideration, and for which many options may exist \cite{bnb}.

The force of the $B\&B$ comes from it being a search algorithm which (indirectly) searches the complete search space of the problem. Since this is not directly feasible, due to the common exponential growth of the solution space, $B\&B$ takes advantage of \textit{bounds}, combined with information regarding the current best solution,to safely discard certain solutions among the search space.

At any point of the algorithm, there is always a \textit{current solution} and a \textit{pool} of unexplored subsets of the solution space. At the beginning of the algorithm, this pool consists of (only) the root node, and at the end of the algorithm, it will consists of an empty set, meaning that the entire search space was successfully explored. 

The initialization of the $B\&B$ requires the \textit{incumbent}, which denotes the objective function value of the current solution, to be initialized as $\infty$. If it is possible to generate an initial feasible solution using some heuristic method, this solution is recorded and its objective value is set as incumbent. The process of generating an initial solution usually has a positive impact on the $B\&B$ algorithm. 

After the initialization, this algorithm enters an iterative process, until the pool of unexplored subsets is empty. This process consists of three main steps: $i$) selection of a node to process; $ii$) the bound calculation; and $iii$) branching.

Branch and Bound algorithms vary according to the established strategies for each of the three main steps of the iterative process, as well as the initial heuristic. In any case, the selected bounding function is the key for any good branch and bounding algorithm, because the selection of a bad function can not be compensated with good choices on the branching and bounding strategies. 

As an example, consider the trivial case where the bounding function is the constant value of zero. It is obvious that this will always be a lower bound to the problem, but it does not produce any quality information of which solutions to discard. Ideally, the value of the bounding function for a given subproblem should be equal to the value of the beast feasible solution  to that problem. This is usually not possible, since subproblems may also be NP-hard. Thus, bounding functions are chosen according to the proximity to the best possible value, and to its time complexity - usually restricted to polynomial time.

To complete this overview it is necessary to reference the most relevant search strategies for the Branch and Bound heuristic, which usually revolve around the Best First, Depth First and Breadth First Search \cite{bnb}. To a more detailed overview of the Branch and Bound algorithm , we refer to J. Clausen's \textit{Branch and Bound algorithms - principles and examples} \cite{bnb}.
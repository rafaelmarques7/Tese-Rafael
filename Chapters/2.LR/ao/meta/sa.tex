\subsubsection{Simulated Annealing}

The SA algorithm was delevoped using an analogy between the phyisical annealing in solids,
and finding the minimum cost configuration in combinatorial optimization problems.
In the phyisical world, annealing is the process of heating a metal until the melting point, 
and reducing the temperature in a controlled way. The decrease in temperatur results in a particle rearangement,
in which lower energy states are reached. When the heating temperature is very high,
and the temperature is decreased very slowly, this will result in the ground state of the solid - its minimum energy state. 
The analogy between physical world and the combinatorial optimization problems 
is achieved by considering that the energy of the metal corresponds to the cost of the solution,
and the particle rearangement consists in the selection of a neighbourhood solution, \cite{simulated_annealing_1}.

The Simulated Annealing algorithms concists in an iterative improvement, which stochastily accepts up-hill moves.
More precisely, the procedure starts with the selection of a feasible solution, aswell as the Initialization of some necessary 
parameters, as the temperature, which will serve as a control variable. After this, the SA enters an iterative proccess.
At the core of this iterative proccess is a local search proccess, which is executed a fixed number of times at each iteration.
Authors usually estabilish this value as 2 times the number of nodes. After this local search procedure is complete,
the temperature is decreased according to its cooling schedule, after which the local search restarts, and the cycle continues,
untill either the execution time is reached, or the temperature reaches 0.

Simulated Annealing differs from other iterative improvement algorithms, because it stochastily accepts up-hill moves,
which allow it to escape from local minima (as happens in, f.e., the Tabu Search). More precisely, at each stage of the local search procedure,
the difference in the energy level, $\Delta$, between the current state and the newly generated state is calculated.
If $\Delta$ is negative, the new state is better than the current one, and it is (always) accepted.
On the contrary, if $\Delta$ is positive, the state is accepted if equation \ref{eq:metropolis} is verified, otherwise, it is rejected.
This equation is often called the Metropolis criteria.
Note that using this criteria, as the temperature approaches zero, less and less bad states are accepted, and at $T=0$ Simulated Annealing 
no detoriations will be accepted at all.

\begin{equation}
\label{eq:metropolis}
  exp(-\frac{\Delta}{T}) > Random[0, 1[
\end{equation}

Time-dependent scheduling problems can also be solved using this meta-heuristic, \cite{simulated_annealing_2},
as the algorithm solely relies on the search of a neighourhood set. The pseudo-code describing the SA procedure 
is presented below. 

In the first works published about the Simulated Annealing, it was proven that if the temperature is cooled very slowly, 
the process will converge to the optimal solution. More precisely, 
if temperature drops no more quickly than $C/log(n)$, where $C$ is the Boltzman constant, and $n$ is the number of steps taken so far.
This result however is not as relevant as it first seems, because this cooling schedule is \textit{very} slow.
Some authors refer that it is faster to do exhaustive search than to follow this colling schedule, \cite{local_search_book}.

The Simulated Annealing procedure varies according to: the cooling schedule; the neighbourhood search criteria; the Markov chain length.
There are several reports which describe the influence of these modules in the overall performance of the SA procedure.
There are other very relevant aspects of this algorithm which may also influence the results as, for example,
the initial and the final temperature. 


\todo{Reinsert the below hidden SA metaheristic procedure.}

% \makeatletter
% \def\BState{\State\hskip-\ALG@thistlm}
% \makeatother

% \begin{algorithm}
% \caption{SA metaheuristic}\label{eq:sa_metacode}
%   \begin{algorithmic}[1]
%     \Procedure{Simulated annealing}{}
%     \State Initialization \Comment{init. sol. $x$, temp. $T_{0}$, iter. counter $n$, rep. counter $R$}
%     \While{$(T_{u} > T_{f})$}
%     \State set $n$ = 0
%     \While{($n$ <= $R$)}
%       generate neighbour solution $y$
%     \State  Calculate $\Delta Z_{yx}$
%     \State if ( $\Delta Z_{yx}$ < 0) accept solution 
%     \State  elif (exp(- $\Delta Z_{yx}/T$) > random(0,1)) accept solution
%     \State  $n$ += 1
%     \EndWhile
%     \State  $u$ += 1
%     \State $  T = T_{u}$
%     \EndWhile
%     \EndProcedure
%   \end{algorithmic}
% \end{algorithm}


